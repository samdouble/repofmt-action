{"version":3,"sources":["../src/index.ts","../src/rules/file-exists.ts","../src/utils/types.ts","../src/rules/file-forbidden.ts","../src/rules/license-exists.ts","../src/rules/readme-exists.ts","../src/rulesMapper.ts","../src/utils/context.ts","../src/utils/config.ts","../src/rules/index.ts"],"sourcesContent":["import type { getOctokit } from '@actions/github';\nimport type { RestEndpointMethodTypes } from '@octokit/plugin-rest-endpoint-methods';\nimport { rulesMapper } from './rulesMapper';\nimport { Config } from './utils/config';\nimport { RuleContext } from './utils/context';\n\nexport { getConfig, configSchema, type Config } from './utils/config';\nexport { RuleContext } from './utils/context';\nexport { rulesMapper } from './rulesMapper';\nexport { fileExists } from './rules/file-exists';\nexport { fileForbidden } from './rules/file-forbidden';\nexport { licenseExists } from './rules/license-exists';\nexport { readmeExists } from './rules/readme-exists';\n\nexport type Octokit = ReturnType<typeof getOctokit>;\nexport type Repository = RestEndpointMethodTypes['repos']['listForAuthenticatedUser']['response']['data'][number];\n\nexport interface RunResult {\n  repository: string;\n  results: {\n    rule: string;\n    errors?: string[];\n    warnings?: string[];\n  }[];\n}\n\nexport async function runRulesForRepo(\n  octokit: Octokit,\n  repo: Repository,\n  config: Config,\n): Promise<RunResult> {\n  const results: RunResult['results'] = [];\n  const context = new RuleContext(octokit, repo);\n\n  for (const ruleConfig of config.rules ?? []) {\n    const { name: rule, level: alertLevel, options: ruleOptions } = ruleConfig;\n    const ruleFunction = rulesMapper[rule as keyof typeof rulesMapper];\n    if (!ruleFunction) {\n      throw new Error(`Rule ${rule} not found`);\n    }\n    const { errors } = await ruleFunction(context, ruleOptions);\n    if (errors.length > 0) {\n      if (alertLevel === 'error') {\n        results.push({ rule, errors });\n      } else if (alertLevel === 'warning') {\n        results.push({ rule, warnings: errors });\n      }\n    }\n  }\n\n  return {\n    repository: repo.full_name,\n    results,\n  };\n}\n\nexport async function run(\n  octokit: Octokit,\n  config: Config,\n): Promise<RunResult[]> {\n  const { data: repos } = await octokit.rest.repos.listForAuthenticatedUser({\n    visibility: 'all',\n    per_page: 100,\n  });\n\n  const results: RunResult[] = [];\n\n  for (const repo of repos) {\n    const repoResult = await runRulesForRepo(octokit, repo, config);\n    results.push(repoResult);\n  }\n\n  return results;\n}\n","import nodePath from 'node:path';\nimport { z } from 'zod';\nimport { AlertLevelSchema } from '../utils/types';\nimport type { RuleContext } from '../utils/context';\n\nexport const EntryTypeSchema = z.enum(['file', 'directory', 'any']).default('file');\n\nexport const FileExistsOptionsSchema = z.object({\n  caseSensitive: z.boolean().default(false),\n  path: z.union([z.string(), z.array(z.string()).min(1)]),\n  type: EntryTypeSchema,\n});\n\nexport const FileExistsSchema = z.object({\n  name: z.literal('file-exists'),\n  level: AlertLevelSchema,\n  options: FileExistsOptionsSchema,\n});\n\nexport type FileExistsOptions = z.input<typeof FileExistsOptionsSchema>;\n\nconst checkEntryExists = async (\n  context: RuleContext,\n  entryPath: string,\n  caseSensitive: boolean,\n  entryType: 'file' | 'directory' | 'any',\n): Promise<boolean> => {\n  const dirPath = nodePath.dirname(entryPath);\n  const entryName = nodePath.basename(entryPath);\n  const directoryPath = dirPath === '.' ? '' : dirPath;\n\n  let contents;\n  try {\n    contents = await context.getContent(directoryPath);\n  } catch {\n    return false;\n  }\n\n  if (!Array.isArray(contents)) {\n    return false;\n  }\n\n  const entry = contents\n    .filter(item => {\n      if (entryType === 'any') return true;\n      if (entryType === 'file') return item.type === 'file';\n      if (entryType === 'directory') return item.type === 'dir';\n      return false;\n    })\n    .find(item => {\n      return caseSensitive\n        ? item.name === entryName\n        : item.name.toLowerCase() === entryName.toLowerCase();\n    });\n\n  return !!entry;\n};\n\nexport const fileExists = async (context: RuleContext, ruleOptions: FileExistsOptions) => {\n  const errors: string[] = [];\n\n  let sanitizedRuleOptions: z.output<typeof FileExistsOptionsSchema>;\n  try {\n    sanitizedRuleOptions = FileExistsOptionsSchema.parse(ruleOptions);\n  } catch (error) {\n    throw new Error(`Invalid rule options: ${error instanceof Error ? error.message : 'Unknown error'}`);\n  }\n\n  const paths = Array.isArray(sanitizedRuleOptions.path)\n    ? sanitizedRuleOptions.path\n    : [sanitizedRuleOptions.path];\n\n  for (const entryPath of paths) {\n    const exists = await checkEntryExists(\n      context,\n      entryPath,\n      sanitizedRuleOptions.caseSensitive,\n      sanitizedRuleOptions.type,\n    );\n    if (exists) {\n      return { errors };\n    }\n  }\n\n  const pathsDisplay = paths.length === 1 ? paths[0] : `one of [${paths.join(', ')}]`;\n  errors.push(`${pathsDisplay} not found`);\n\n  return { errors };\n};\n","import { z } from 'zod';\n\nexport const AlertLevelSchema = z.enum(['error', 'warning']);\n","import nodePath from 'node:path';\nimport { z } from 'zod';\nimport { AlertLevelSchema } from '../utils/types';\nimport type { RuleContext } from '../utils/context';\n\nexport const EntryTypeSchema = z.enum(['file', 'directory', 'any']).default('file');\n\nexport const FileForbiddenOptionsSchema = z.object({\n  caseSensitive: z.boolean().default(false),\n  path: z.union([z.string(), z.array(z.string()).min(1)]),\n  type: EntryTypeSchema,\n});\n\nexport const FileForbiddenSchema = z.object({\n  name: z.literal('file-forbidden'),\n  level: AlertLevelSchema,\n  options: FileForbiddenOptionsSchema,\n});\n\nexport type FileForbiddenOptions = z.input<typeof FileForbiddenOptionsSchema>;\n\nconst checkEntryExists = async (\n  context: RuleContext,\n  entryPath: string,\n  caseSensitive: boolean,\n  entryType: 'file' | 'directory' | 'any',\n): Promise<boolean> => {\n  const dirPath = nodePath.dirname(entryPath);\n  const entryName = nodePath.basename(entryPath);\n  const directoryPath = dirPath === '.' ? '' : dirPath;\n\n  let contents;\n  try {\n    contents = await context.getContent(directoryPath);\n  } catch {\n    return false;\n  }\n\n  if (!Array.isArray(contents)) {\n    return false;\n  }\n\n  const entry = contents\n    .filter(item => {\n      if (entryType === 'any') return true;\n      if (entryType === 'file') return item.type === 'file';\n      if (entryType === 'directory') return item.type === 'dir';\n      return false;\n    })\n    .find(item => {\n      return caseSensitive\n        ? item.name === entryName\n        : item.name.toLowerCase() === entryName.toLowerCase();\n    });\n\n  return !!entry;\n};\n\nexport const fileForbidden = async (context: RuleContext, ruleOptions: FileForbiddenOptions) => {\n  const errors: string[] = [];\n\n  let sanitizedRuleOptions: z.output<typeof FileForbiddenOptionsSchema>;\n  try {\n    sanitizedRuleOptions = FileForbiddenOptionsSchema.parse(ruleOptions);\n  } catch (error) {\n    throw new Error(`Invalid rule options: ${error instanceof Error ? error.message : 'Unknown error'}`);\n  }\n\n  const paths = Array.isArray(sanitizedRuleOptions.path)\n    ? sanitizedRuleOptions.path\n    : [sanitizedRuleOptions.path];\n\n  const foundEntries: string[] = [];\n  for (const entryPath of paths) {\n    const exists = await checkEntryExists(\n      context,\n      entryPath,\n      sanitizedRuleOptions.caseSensitive,\n      sanitizedRuleOptions.type,\n    );\n    if (exists) {\n      foundEntries.push(entryPath);\n    }\n  }\n\n  if (foundEntries.length > 0) {\n    const entriesDisplay = foundEntries.length === 1\n      ? foundEntries[0]\n      : `[${foundEntries.join(', ')}]`;\n    errors.push(`${entriesDisplay} should not exist`);\n  }\n\n  return { errors };\n};\n","import { z } from 'zod';\nimport { fileExists } from './file-exists';\nimport { AlertLevelSchema } from '../utils/types';\nimport type { RuleContext } from '../utils/context';\n\nexport const LicenseExistsOptionsSchema = z.object({\n  caseSensitive: z.boolean().default(false),\n  path: z.union([z.string(), z.array(z.string()).min(1)]).default('LICENSE.md'),\n});\n\nexport const LicenseExistsSchema = z.object({\n  name: z.literal('license/exists'),\n  level: AlertLevelSchema,\n  options: LicenseExistsOptionsSchema,\n});\n\nexport type LicenseExistsOptions = z.input<typeof LicenseExistsOptionsSchema>;\n\nexport const licenseExists = async (context: RuleContext, ruleOptions: LicenseExistsOptions) => {\n  let sanitizedRuleOptions: z.output<typeof LicenseExistsOptionsSchema>;\n  try {\n    sanitizedRuleOptions = LicenseExistsOptionsSchema.parse(ruleOptions);\n  } catch (error) {\n    throw new Error(`Invalid rule options: ${error instanceof Error ? error.message : 'Unknown error'}`);\n  }\n  const { errors } = await fileExists(context, sanitizedRuleOptions);\n  return { errors };\n};\n","import { z } from 'zod';\nimport { fileExists } from './file-exists';\nimport { AlertLevelSchema } from '../utils/types';\nimport type { RuleContext } from '../utils/context';\n\nexport const ReadmeExistsOptionsSchema = z.object({\n  caseSensitive: z.boolean().optional().default(false),\n  path: z.union([z.string(), z.array(z.string()).min(1)]).optional().default('README.md'),\n});\n\nexport const ReadmeExistsSchema = z.object({\n  name: z.literal('readme/exists'),\n  level: AlertLevelSchema,\n  options: ReadmeExistsOptionsSchema,\n});\n\nexport type ReadmeExistsOptions = z.input<typeof ReadmeExistsOptionsSchema>;\n\nexport const readmeExists = async (context: RuleContext, ruleOptions: ReadmeExistsOptions) => {\n  let sanitizedRuleOptions: z.output<typeof ReadmeExistsOptionsSchema>;\n  try {\n    sanitizedRuleOptions = ReadmeExistsOptionsSchema.parse(ruleOptions);\n  } catch (error) {\n    throw new Error(`Invalid rule options: ${error instanceof Error ? error.message : 'Unknown error'}`);\n  }\n  const { errors } = await fileExists(context, sanitizedRuleOptions);\n  return { errors };\n};\n","import { fileExists } from \"./rules/file-exists\";\nimport { fileForbidden } from \"./rules/file-forbidden\";\nimport { licenseExists } from \"./rules/license-exists\";\nimport { readmeExists } from \"./rules/readme-exists\";\n\nexport const rulesMapper = {\n  'file-exists': fileExists,\n  'file-forbidden': fileForbidden,\n  'license/exists': licenseExists,\n  'readme/exists': readmeExists,\n};\n","import type { getOctokit } from '@actions/github';\nimport type { RestEndpointMethodTypes } from '@octokit/plugin-rest-endpoint-methods';\n\nexport type Octokit = ReturnType<typeof getOctokit>;\nexport type Repository = RestEndpointMethodTypes['repos']['listForAuthenticatedUser']['response']['data'][number];\nexport type RepoContent = RestEndpointMethodTypes['repos']['getContent']['response']['data'];\n\nexport class RuleContext {\n  private contentCache: Map<string, RepoContent> = new Map();\n\n  constructor(\n    public readonly octokit: Octokit,\n    public readonly repository: Repository,\n  ) {}\n\n  async getContent(path: string = ''): Promise<RepoContent> {\n    const cacheKey = `${this.repository.full_name}:${path}`;\n\n    if (this.contentCache.has(cacheKey)) {\n      return this.contentCache.get(cacheKey)!;\n    }\n\n    const { data: contents } = await this.octokit.rest.repos.getContent({\n      owner: this.repository.owner.login,\n      repo: this.repository.name,\n      path,\n    });\n\n    this.contentCache.set(cacheKey, contents);\n    return contents;\n  }\n\n  clearCache(): void {\n    this.contentCache.clear();\n  }\n}\n","import { createJiti } from 'jiti';\nimport * as fs from 'node:fs';\nimport * as path from 'node:path';\nimport { pathToFileURL } from 'node:url';\nimport { z } from 'zod';\nimport { rulesConfigSchema } from '../rules';\n\nexport const configSchema = z.object({\n  rules: rulesConfigSchema.optional().default([]),\n});\n\nexport type Config = z.infer<typeof configSchema>;\n\nconst CONFIG_FILES = [\n  'repofmt.config.ts',\n  'repofmt.config.js',\n  'repofmt.config.mjs',\n  'repofmt.config.cjs',\n];\n\nexport const getConfig = async (configPathArg?: string): Promise<Config> => {\n  let configPath: string | undefined;\n\n  if (configPathArg) {\n    const resolvedPath = path.isAbsolute(configPathArg)\n      ? configPathArg\n      : path.join(process.cwd(), configPathArg);\n    if (!fs.existsSync(resolvedPath)) {\n      throw new Error(`Config file not found: ${configPathArg}`);\n    }\n    configPath = resolvedPath;\n  } else {\n    const workspaceRoot = process.cwd();\n    for (const configFile of CONFIG_FILES) {\n      const candidatePath = path.join(workspaceRoot, configFile);\n      if (fs.existsSync(candidatePath)) {\n        configPath = candidatePath;\n        break;\n      }\n    }\n\n    if (!configPath) {\n      throw new Error(\n        `No config file found. Create one of: ${CONFIG_FILES.join(', ')}`,\n      );\n    }\n  }\n\n  console.info(`Found config at ${configPath}`);\n\n  const jiti = createJiti(pathToFileURL(__filename).href);\n  const configModule = await jiti.import(configPath);\n  const rawConfig = (configModule as { default?: unknown }).default ?? configModule;\n\n  const result = configSchema.safeParse(rawConfig);\n  if (!result.success) {\n    throw new Error(`Invalid config: ${result.error.message}`);\n  }\n\n  return result.data;\n};\n","import z from 'zod';\nimport { FileExistsSchema } from './file-exists';\nimport { FileForbiddenSchema } from './file-forbidden';\nimport { LicenseExistsSchema } from './license-exists';\nimport { ReadmeExistsSchema } from './readme-exists';\n\nexport const ruleConfigSchema = z.union([\n  FileExistsSchema,\n  FileForbiddenSchema,\n  LicenseExistsSchema,\n  ReadmeExistsSchema,\n]);\n\nexport const rulesConfigSchema = z.array(ruleConfigSchema);\n\nexport type RulesConfig = z.infer<typeof rulesConfigSchema>;\n"],"mappings":"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","names":["import_zod","nodePath","import_node_path","import_zod","EntryTypeSchema","checkEntryExists","nodePath","import_zod","import_zod","path","import_zod","import_zod","z"]}